###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         29/Aug/2017  18:30:13 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZStack-C #
#                          C2530-r200\Components\hal\target\CC2530EB\IR.c     #
#    Command line       =  -f D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZStac #
#                          k-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2 #
#                          530DB\f8wCoord.cfg (-DCPU32MHZ -DROOT=__near_func  #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8         #
#                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)    #
#                          -f D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZStac #
#                          k-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2 #
#                          530DB\f8wConfig.cfg (-DZIGBEEPRO -DSECURE=0        #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0x0045                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 D:\zigbee实验\实验指导书\Co #
#                          de\Cap2_ZStack\ZStack-CC2530-r200\Components\hal\t #
#                          arget\CC2530EB\IR.c -D ZTOOL_P1 -D MT_TASK -D      #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D SAPP_ZSTACK -lC      #
#                          D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZStack-C #
#                          C2530-r200\Projects\SappWsn\CoordinatorEB\List\    #
#                          -lA D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZSta #
#                          ck-CC2530-r200\Projects\SappWsn\CoordinatorEB\List #
#                          \ --diag_suppress Pe001,Pa010 -o                   #
#                          D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZStack-C #
#                          C2530-r200\Projects\SappWsn\CoordinatorEB\Obj\ -e  #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZStac #
#                          k-CC2530-r200\Projects\SappWsn\ -I                 #
#                          D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZStack-C #
#                          C2530-r200\Projects\SappWsn\Source\ -I             #
#                          D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZStack-C #
#                          C2530-r200\Projects\SappWsn\..\zstack\ZMain\TI2530 #
#                          DB\ -I D:\zigbee实验\实验指导书\Code\Cap2_ZStack\Z #
#                          Stack-CC2530-r200\Projects\SappWsn\..\..\Component #
#                          s\hal\include\ -I D:\zigbee实验\实验指导书\Code\Ca #
#                          p2_ZStack\ZStack-CC2530-r200\Projects\SappWsn\..\. #
#                          .\Components\hal\target\CC2530EB\ -I               #
#                          D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZStack-C #
#                          C2530-r200\Projects\SappWsn\..\..\Components\mac\i #
#                          nclude\ -I D:\zigbee实验\实验指导书\Code\Cap2_ZSta #
#                          ck\ZStack-CC2530-r200\Projects\SappWsn\..\..\Compo #
#                          nents\mac\high_level\ -I                           #
#                          D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZStack-C #
#                          C2530-r200\Projects\SappWsn\..\..\Components\mac\l #
#                          ow_level\srf04\ -I D:\zigbee实验\实验指导书\Code\C #
#                          ap2_ZStack\ZStack-CC2530-r200\Projects\SappWsn\..\ #
#                          ..\Components\mac\low_level\srf04\single_chip\ -I  #
#                          D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZStack-C #
#                          C2530-r200\Projects\SappWsn\..\..\Components\mt\   #
#                          -I D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZStac #
#                          k-CC2530-r200\Projects\SappWsn\..\..\Components\os #
#                          al\include\ -I D:\zigbee实验\实验指导书\Code\Cap2_ #
#                          ZStack\ZStack-CC2530-r200\Projects\SappWsn\..\..\C #
#                          omponents\services\saddr\ -I                       #
#                          D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZStack-C #
#                          C2530-r200\Projects\SappWsn\..\..\Components\servi #
#                          ces\sdata\ -I D:\zigbee实验\实验指导书\Code\Cap2_Z #
#                          Stack\ZStack-CC2530-r200\Projects\SappWsn\..\..\Co #
#                          mponents\stack\af\ -I D:\zigbee实验\实验指导书\Cod #
#                          e\Cap2_ZStack\ZStack-CC2530-r200\Projects\SappWsn\ #
#                          ..\..\Components\stack\nwk\ -I                     #
#                          D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZStack-C #
#                          C2530-r200\Projects\SappWsn\..\..\Components\stack #
#                          \sapi\ -I D:\zigbee实验\实验指导书\Code\Cap2_ZStac #
#                          k\ZStack-CC2530-r200\Projects\SappWsn\..\..\Compon #
#                          ents\stack\sec\ -I D:\zigbee实验\实验指导书\Code\C #
#                          ap2_ZStack\ZStack-CC2530-r200\Projects\SappWsn\..\ #
#                          ..\Components\stack\sys\ -I                        #
#                          D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZStack-C #
#                          C2530-r200\Projects\SappWsn\..\..\Components\stack #
#                          \zdo\ -I D:\zigbee实验\实验指导书\Code\Cap2_ZStack #
#                          \ZStack-CC2530-r200\Projects\SappWsn\..\..\Compone #
#                          nts\zmac\ -I D:\zigbee实验\实验指导书\Code\Cap2_ZS #
#                          tack\ZStack-CC2530-r200\Projects\SappWsn\..\..\Com #
#                          ponents\zmac\f8w\ -Ohz --require_prototypes        #
#    List file          =  D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZStack-C #
#                          C2530-r200\Projects\SappWsn\CoordinatorEB\List\IR. #
#                          lst                                                #
#    Object file        =  D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZStack-C #
#                          C2530-r200\Projects\SappWsn\CoordinatorEB\Obj\IR.r #
#                          51                                                 #
#                                                                             #
#                                                                             #
###############################################################################

D:\zigbee实验\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\Components\hal\target\CC2530EB\IR.c
      1          /***********************************************************
      2          **  FileName:         IR.c
      3          **  Introductions:    Sunplusapp CC2530 ZigBee Node IR Romoter Signal Send Functions
      4          **  Last Modify time: 2013.05.21
      5          **  Modify:           修改红外编码发送，优化时序，添加注释
      6          **  Author:           GuoZhenjiang <zhenjiang.guo@sunplusapp.com>
      7          ***********************************************************/
      8          
      9          #include "IR.h"

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xaf
   \   unsigned char volatile __sfr T1STAT
   \                     T1STAT:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc0
   \   union <unnamed> volatile __sfr _A_IRCON
   \                     _A_IRCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xcb
   \   unsigned char volatile __sfr T3CTL
   \                     T3CTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xcc
   \   unsigned char volatile __sfr T3CCTL0
   \                     T3CCTL0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xcd
   \   unsigned char volatile __sfr T3CC0
   \                     T3CC0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd8
   \   union <unnamed> volatile __sfr _A_TIMIF
   \                     _A_TIMIF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xda
   \   unsigned char volatile __sfr T1CC0L
   \                     T1CC0L:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xdb
   \   unsigned char volatile __sfr T1CC0H
   \                     T1CC0H:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe4
   \   unsigned char volatile __sfr T1CTL
   \                     T1CTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe5
   \   unsigned char volatile __sfr T1CCTL0
   \                     T1CCTL0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf4
   \   unsigned char volatile __sfr P1SEL
   \                     P1SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf5
   \   unsigned char volatile __sfr P2SEL
   \                     P2SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1
     10          #include "OSAL.h"
     11          
     12          #if defined(HAL_IRENC) && (HAL_IRENC == TRUE)
     13          
     14          // 定时器1中自增量,控制每一位编码的周期

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     15          volatile uint16  T1_80usCnt = 0;
   \                     T1_80usCnt:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     16          
     17          // Timer1红外编码初始化
     18          void IRSend_T1_Init(void);
     19          // Timer3红外编码初始化
     20          void IRSend_T3_Init(void);
     21          // Timer1 & Timer3 中断处理函数声明
     22          __near_func __interrupt void IRSend_T1IntHandle(void);
     23          __near_func __interrupt void IRSend_T3IntHandle(void);
     24          
     25          /***********************************************************
     26          **  函数名称: GenIR
     27          **  实现功能: 系统时钟设置
     28          **  入口参数: IRData:   红外编码数据首地址
     29          **            Mode:     引导码分类:1 周期9ms    2:周期13.56ms
     30          **            CodeLen:  编码位数(bit,不是Byte)
     31          **  返回结果: 0:发送失败    1:发送成功
     32          ***********************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     33          int GenIR(uint8 *IRData , uint8 Mode , uint8 CodeLen )
   \                     GenIR:
     34          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   89..         MOV     ?V0 + 2,R1
     35              uint16  GuideCodeLen=0;
   \   00000B   75..00       MOV     ?V0 + 0,#0x0
     36              static IRSendSta_t IRSendSta = IRSta_Guide;
     37              static uint8 cntByte=0, cntbit=0, bitNum;
     38              bitNum = CodeLen;       //保存位数
   \   00000E   EC           MOV     A,R4
   \   00000F   90....       MOV     DPTR,#??bitNum
   \   000012   F0           MOVX    @DPTR,A
     39          
     40              if(Mode == 1)
   \   000013   7401         MOV     A,#0x1
   \   000015   65..         XRL     A,?V0 + 2
   \   000017   7005         JNZ     ??GenIR_0
     41                GuideCodeLen = 56;//226;   引导码长度（4.5ms、4.5ms）
   \   000019   75..38       MOV     ?V0 + 0,#0x38
   \   00001C   8009         SJMP    ??GenIR_1
     42              else if(Mode == 2)
   \                     ??GenIR_0:
   \   00001E   7402         MOV     A,#0x2
   \   000020   65..         XRL     A,?V0 + 2
   \   000022   7003         JNZ     ??GenIR_1
     43                GuideCodeLen = 114;   //引导码长度（9ms、4.5ms）
   \   000024   75..72       MOV     ?V0 + 0,#0x72
     44          
     45              IRSend_T1_Init();
   \                     ??GenIR_1:
   \   000027                ; Setup parameters for call to function IRSend_T1_Init
   \   000027   12....       LCALL   ??IRSend_T1_Init?relay
     46              IRSend_T3_Init();
   \   00002A                ; Setup parameters for call to function IRSend_T3_Init
   \   00002A   12....       LCALL   ??IRSend_T3_Init?relay
     47              IR_SEL_IOOUT;
   \   00002D   12....       LCALL   ?Subroutine2 & 0xFFFF
     48              CLR_IOB_BIT;
     49              IRSendSta = IRSta_Guide;
     50              T1_80usCnt = 0;
   \                     ??CrossCallReturnLabel_4:
   \   000030   90....       MOV     DPTR,#T1_80usCnt
   \   000033   E4           CLR     A
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   F0           MOVX    @DPTR,A
     51              IR_SEL_T3PWM;
   \                     ??GenIR_2:
   \   000037   43F408       ORL     0xf4,#0x8
   \   00003A   8003         SJMP    ??CrossCallReturnLabel_5
     52              while(1)
     53              {
     54                  // 查询红外编码发送状态
     55                  switch(IRSendSta)
     56                  {
     57                      // 引导码阶段
     58                  case IRSta_Guide:	
     59                      // 引导码4.5ms或9ms载波阶段
     60                      if(T1_80usCnt <= GuideCodeLen)
     61                      {
     62                          IRSendSta = IRSta_Guide;
     63                          IR_SEL_T3PWM;
     64                      }
     65                      // 引导码4.5ms低电平阶段
     66                      else if((T1_80usCnt > GuideCodeLen) && (T1_80usCnt <= GuideCodeLen+56))
     67                      {
     68                          IRSendSta = IRSta_Guide;
     69                          IR_SEL_IOOUT;
   \                     ??GenIR_3:
   \   00003C   12....       LCALL   ?Subroutine2 & 0xFFFF
     70                          CLR_IOB_BIT;
     71                      }
   \                     ??CrossCallReturnLabel_5:
   \   00003F   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000042   50F3         JNC     ??GenIR_2
   \   000044   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000047   5017         JNC     ??GenIR_4
   \   000049   E5..         MOV     A,?V0 + 0
   \   00004B   2438         ADD     A,#0x38
   \   00004D   FA           MOV     R2,A
   \   00004E   E4           CLR     A
   \   00004F   3400         ADDC    A,#0x0
   \   000051   FB           MOV     R3,A
   \   000052   90....       MOV     DPTR,#T1_80usCnt
   \   000055   E0           MOVX    A,@DPTR
   \   000056   F8           MOV     R0,A
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F9           MOV     R1,A
   \   00005A   EA           MOV     A,R2
   \   00005B   98           SUBB    A,R0
   \   00005C   EB           MOV     A,R3
   \   00005D   99           SUBB    A,R1
   \   00005E   50DC         JNC     ??GenIR_3
     72                      // 引导码发送完毕,准备发送数据位
     73                      else
     74                      {
     75                          IRSendSta = IRSta_T3PWM;
     76                          IR_SEL_T3PWM;
   \                     ??GenIR_4:
   \   000060   12....       LCALL   ?Subroutine5 & 0xFFFF
     77                          T1_80usCnt = 0;
     78                      }
     79                      break;
     80                      // 数据位中的位0、位1的0.56ms的38kHz载波阶段
     81                  case IRSta_T3PWM:
     82                      if(T1_80usCnt >= 7)     // 7 * 80us = 560us
   \                     ??CrossCallReturnLabel_11:
   \   000063   90....       MOV     DPTR,#T1_80usCnt
   \   000066   C3           CLR     C
   \   000067   E0           MOVX    A,@DPTR
   \   000068   9407         SUBB    A,#0x7
   \   00006A   A3           INC     DPTR
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   9400         SUBB    A,#0x0
   \   00006E   40F3         JC      ??CrossCallReturnLabel_11
     83                      {
     84                          IR_SEL_IOOUT;
   \   000070   12....       LCALL   ?Subroutine1 & 0xFFFF
     85                          CLR_IOB_BIT;
     86                          IRSendSta = IRSta_Data0;
     87                      }
     88                      break;
     89                      // 数据位中的位0、位1的低电平持续阶段
     90                  case IRSta_Data0:
     91                      //发送数据0,低电平持续 0.565ms。
     92                      if(!(IRData[cntByte] & (0x80 >> (cntbit % 8))))
   \                     ??CrossCallReturnLabel_2:
   \   000073   E0           MOVX    A,@DPTR
   \   000074   5407         ANL     A,#0x7
   \   000076   F8           MOV     R0,A
   \   000077   7480         MOV     A,#-0x80
   \   000079   B80002       CJNE    R0,#0x0,??GenIR_5
   \   00007C   8004         SJMP    ??GenIR_6
   \                     ??GenIR_5:
   \   00007E   C3           CLR     C
   \   00007F   13           RRC     A
   \   000080   D8FC         DJNZ    R0,??GenIR_5
   \                     ??GenIR_6:
   \   000082   C0E0         PUSH    A
   \   000084   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000087   D0E0         POP     A
   \   000089   F8           MOV     R0,A
   \   00008A   E0           MOVX    A,@DPTR
   \   00008B   58           ANL     A,R0
   \   00008C   701A         JNZ     ??GenIR_7
     93                      {
     94                          if(T1_80usCnt >= 14)
   \   00008E   90....       MOV     DPTR,#T1_80usCnt
   \   000091   C3           CLR     C
   \   000092   E0           MOVX    A,@DPTR
   \   000093   940E         SUBB    A,#0xe
   \   000095   A3           INC     DPTR
   \   000096   E0           MOVX    A,@DPTR
   \   000097   9400         SUBB    A,#0x0
   \   000099   403D         JC      ??GenIR_8
     95                          {
     96                              IR_SEL_T3PWM;
   \   00009B   12....       LCALL   ?Subroutine0 & 0xFFFF
     97                              T1_80usCnt = 0;
     98                              cntbit++;
     99                              if(0 == (cntbit % 8))
   \                     ??CrossCallReturnLabel_0:
   \   00009E   7038         JNZ     ??GenIR_8
    100                                  cntByte++;
   \                     ??GenIR_9:
   \   0000A0   90....       MOV     DPTR,#??cntByte
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   04           INC     A
   \   0000A5   F0           MOVX    @DPTR,A
   \   0000A6   8030         SJMP    ??GenIR_8
    101                          }
    102                      }
    103                      //发送数据1,低电平持续 1.685ms。
    104                      else if(IRData[cntByte] & (0x80 >> (cntbit % 8)))
   \                     ??GenIR_7:
   \   0000A8   90....       MOV     DPTR,#??cntbit
   \   0000AB   E0           MOVX    A,@DPTR
   \   0000AC   5407         ANL     A,#0x7
   \   0000AE   F8           MOV     R0,A
   \   0000AF   7480         MOV     A,#-0x80
   \   0000B1   B80002       CJNE    R0,#0x0,??GenIR_10
   \   0000B4   8004         SJMP    ??GenIR_11
   \                     ??GenIR_10:
   \   0000B6   C3           CLR     C
   \   0000B7   13           RRC     A
   \   0000B8   D8FC         DJNZ    R0,??GenIR_10
   \                     ??GenIR_11:
   \   0000BA   C0E0         PUSH    A
   \   0000BC   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   0000BF   D0E0         POP     A
   \   0000C1   F8           MOV     R0,A
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   58           ANL     A,R0
   \   0000C4   6012         JZ      ??GenIR_8
    105                      {
    106                          if(T1_80usCnt >= 28)
   \   0000C6   90....       MOV     DPTR,#T1_80usCnt
   \   0000C9   C3           CLR     C
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   941C         SUBB    A,#0x1c
   \   0000CD   A3           INC     DPTR
   \   0000CE   E0           MOVX    A,@DPTR
   \   0000CF   9400         SUBB    A,#0x0
   \   0000D1   4005         JC      ??GenIR_8
    107                          {				
    108                              IR_SEL_T3PWM;
   \   0000D3   12....       LCALL   ?Subroutine0 & 0xFFFF
    109                              T1_80usCnt = 0;
    110                              cntbit++;
    111                              if(0 == (cntbit % 8))
    112                                  cntByte++;
    113                          }
    114                      }	
   \                     ??CrossCallReturnLabel_1:
   \   0000D6   60C8         JZ      ??GenIR_9
    115                      // 发送完毕?
    116                      if(cntbit >= bitNum)	
   \                     ??GenIR_8:
   \   0000D8   90....       MOV     DPTR,#??bitNum
   \   0000DB   E0           MOVX    A,@DPTR
   \   0000DC   F8           MOV     R0,A
   \   0000DD   90....       MOV     DPTR,#??cntbit
   \   0000E0   E0           MOVX    A,@DPTR
   \   0000E1   C3           CLR     C
   \   0000E2   98           SUBB    A,R0
   \   0000E3   5003         JNC     $+5
   \   0000E5   02....       LJMP    ??CrossCallReturnLabel_11 & 0xFFFF
    117                          IRSendSta = IRSta_Stop;
   \   0000E8   90....       MOV     DPTR,#??IRSendSta
   \   0000EB   7403         MOV     A,#0x3
   \   0000ED   F0           MOVX    @DPTR,A
    118                      // 继续发送?
    119                      else
    120                          IRSendSta = IRSta_T3PWM;
    121                      break;
    122                      // 红外编码数据部分发送完毕
    123                  case IRSta_Stop:
    124                      // 一组编码发送完毕  结束位是 0.56ms 的 38K 载波
    125                      while(T1_80usCnt < 7)
   \                     ??GenIR_12:
   \   0000EE   90....       MOV     DPTR,#T1_80usCnt
   \   0000F1   C3           CLR     C
   \   0000F2   E0           MOVX    A,@DPTR
   \   0000F3   9407         SUBB    A,#0x7
   \   0000F5   A3           INC     DPTR
   \   0000F6   E0           MOVX    A,@DPTR
   \   0000F7   9400         SUBB    A,#0x0
   \   0000F9   40F3         JC      ??GenIR_12
    126                          ;
    127                      STOP_T1_T3; // stop T1 & T3
   \   0000FB   75CB00       MOV     0xcb,#0x0
   \   0000FE   75E400       MOV     0xe4,#0x0
    128                      T1_80usCnt = 0;
   \   000101   90....       MOV     DPTR,#T1_80usCnt
   \   000104   E4           CLR     A
   \   000105   F0           MOVX    @DPTR,A
   \   000106   A3           INC     DPTR
   \   000107   F0           MOVX    @DPTR,A
    129                      IR_SEL_IOOUT;
   \   000108   12....       LCALL   ?Subroutine1 & 0xFFFF
    130                      CLR_IOB_BIT;
    131                      cntbit = 0;
   \                     ??CrossCallReturnLabel_3:
   \   00010B   F0           MOVX    @DPTR,A
    132                      cntByte = 0;
   \   00010C   90....       MOV     DPTR,#??cntByte
   \   00010F   F0           MOVX    @DPTR,A
    133                      return 1;
   \   000110   7A01         MOV     R2,#0x1
   \   000112   FB           MOV     R3,A
   \   000113   7F04         MOV     R7,#0x4
   \   000115   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000118                REQUIRE P1SEL
   \   000118                REQUIRE P1DIR
   \   000118                REQUIRE _A_P1
   \   000118                REQUIRE T3CTL
   \   000118                REQUIRE T1CTL
    134                      break;
    135                  default:
    136                      return 0;
    137                      break;
    138                  }							
    139              }
    140          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   90....       MOV     DPTR,#??cntByte
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   EE           MOV     A,R6
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   EF           MOV     A,R7
   \   00000A   3400         ADDC    A,#0x0
   \   00000C   F583         MOV     DPH,A
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   90....       MOV     DPTR,#T1_80usCnt
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F9           MOV     R1,A
   \   000008   C3           CLR     C
   \   000009   E5..         MOV     A,?V0 + 0
   \   00000B   98           SUBB    A,R0
   \   00000C   E4           CLR     A
   \   00000D   99           SUBB    A,R1
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000003   90....       MOV     DPTR,#??cntbit
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000003   90....       MOV     DPTR,#??cntbit
   \   000006   E0           MOVX    A,@DPTR
   \   000007   04           INC     A
   \   000008   F0           MOVX    @DPTR,A
   \   000009   5407         ANL     A,#0x7
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   43F408       ORL     0xf4,#0x8
   \   000003   90....       MOV     DPTR,#T1_80usCnt
   \   000006   E4           CLR     A
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   53F4F7       ANL     0xf4,#0xf7
   \   000003   43FE08       ORL     0xfe,#0x8
   \   000006   C293         CLR     0x90.3
   \   000008   22           RET

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??IRSendSta:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??cntByte:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??cntbit:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??bitNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    141          
    142          /***********************************************************
    143          **  函数名称: IRSend_T1_Init
    144          **  实现功能: 红外编码发送定时器1初始化
    145          **  入口参数: None
    146          **  返回结果: None
    147          ***********************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    148          void IRSend_T1_Init(void)
   \                     IRSend_T1_Init:
    149          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    150              T1CTL = 0x0E;       // f = 32MHz / 128 = 250 000Hz, T = 4us;模模式,从0~T1CC0反复计数。
   \   000004   75E40E       MOV     0xe4,#0xe
    151              T1CCTL0 = 0x44;     // Timer1通道0中断允许,比较匹配模式,比较比配时输出置位。
   \   000007   75E544       MOV     0xe5,#0x44
    152              T1CC0L = 19;        // 先写T1CC0L,再写T1CC0H,T1CNT=0时更新。 4us*20 = 80us;
   \   00000A   75DA13       MOV     0xda,#0x13
    153              T1CC0H = 0;
   \   00000D   75DB00       MOV     0xdb,#0x0
    154              TIMIF |= BIT_1(6);  // TIMIF.T1OVFIM Timer1溢出中断允许
   \   000010   D2DE         SETB    0xd8.6
    155              IEN1 |= BIT_1(1);   // IEN1.T1IE Timer1总中断允许
   \   000012   D2B9         SETB    0xb8.1
    156              EA = 1;             // 打开全局总中断
   \   000014   D2AF         SETB    0xa8.7
    157              T1_80usCnt = 0;     // 80us溢出中断自增量清零
   \   000016   90....       MOV     DPTR,#T1_80usCnt
   \   000019   E4           CLR     A
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   F0           MOVX    @DPTR,A
    158          }
   \   00001D   D083         POP     DPH
   \   00001F   D082         POP     DPL
   \   000021   02....       LJMP    ?BRET
   \   000024                REQUIRE T1CTL
   \   000024                REQUIRE T1CCTL0
   \   000024                REQUIRE T1CC0L
   \   000024                REQUIRE T1CC0H
   \   000024                REQUIRE _A_TIMIF
   \   000024                REQUIRE _A_IEN1
   \   000024                REQUIRE _A_IEN0
    159          
    160          /***********************************************************
    161          **  函数名称: IRSend_T3_Init
    162          **  实现功能: 红外编码发送定时器3初始化
    163          **  入口参数: None
    164          **  返回结果: None
    165          ***********************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    166          void IRSend_T3_Init(void)
   \                     IRSend_T3_Init:
    167          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    168              P1SEL |= BIT_1(3);      // P1.3 us as T3 PWM Out Pin.
   \   000000   43F408       ORL     0xf4,#0x8
    169              T3CTL = 0x02;           // T3CTL.MODE[10] 模模式,从0~T3CC0反复计数
   \   000003   75CB02       MOV     0xcb,#0x2
    170              T3CTL |= BIT_1(5);      // T3CTL.MODE[001] f = 32MHz / 2 = 16MHz;
   \   000006   43CB20       ORL     0xcb,#0x20
    171              T3CCTL0 |= BIT_1(2);    // T3CCTL0.MODE 输出比较比配模式
   \   000009   43CC04       ORL     0xcc,#0x4
    172              T3CCTL0 |= BIT_1(4);    // T3CCTL0.CMP[010] 比较匹配时,输出取反
   \   00000C   43CC10       ORL     0xcc,#0x10
    173          
    174              T3CC0 = 208;            // Timer3通道0输出比较匹配上限值,16MHz / 208 = 76923.076923Hz; 76923 / 2 =38k(比较匹配时取反).
   \   00000F   75CDD0       MOV     0xcd,#-0x30
    175              T3CTL |= BIT_1(4);      // T3CTL.START 启动Timer3
   \   000012   43CB10       ORL     0xcb,#0x10
    176              P2SEL |= BIT_1(5);      // P2SEL.PRI2P1 当USART1和Timer3占用相同引脚,Timer3优先。
   \   000015   43F520       ORL     0xf5,#0x20
    177              T3CCTL0 |= BIT_1(6);    // T3CCTL0.IM Timer3通道0中断允许。
   \   000018   43CC40       ORL     0xcc,#0x40
    178              IEN1 |= BIT_1(3);       // IEN1.T3IE Timer3总中断允许。
   \   00001B   D2BB         SETB    0xb8.3
    179              EA = 1;                 // 全局总中断允许。
   \   00001D   D2AF         SETB    0xa8.7
    180          }
   \   00001F   02....       LJMP    ?BRET
   \   000022                REQUIRE P1SEL
   \   000022                REQUIRE T3CTL
   \   000022                REQUIRE T3CCTL0
   \   000022                REQUIRE T3CC0
   \   000022                REQUIRE P2SEL
   \   000022                REQUIRE _A_IEN1
   \   000022                REQUIRE _A_IEN0
    181          
    182          /***********************************************************
    183          **  函数名称: IRSendInit
    184          **  实现功能: 红外编码发送初始化
    185          **  入口参数: None
    186          **  返回结果: None
    187          ***********************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    188          void IRSendInit(void)
   \                     IRSendInit:
    189          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    190              IR_SEL_IOOUT;
   \   000000   12....       LCALL   ?Subroutine2 & 0xFFFF
    191              CLR_IOB_BIT;
    192          }
   \                     ??CrossCallReturnLabel_6:
   \   000003   02....       LJMP    ?BRET
   \   000006                REQUIRE P1SEL
   \   000006                REQUIRE P1DIR
   \   000006                REQUIRE _A_P1
    193          
    194          /***********************************************************
    195          **  函数名称: IRSend_T1IntHandle
    196          **  实现功能: Timer1 红外编码发送中的中断处理函数
    197          **  入口参数: None
    198          **  返回结果: None
    199          ***********************************************************/
    200          #pragma vector = T1_VECTOR

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    201          __interrupt void IRSend_T1IntHandle(void)
   \                     IRSend_T1IntHandle:
    202          {
   \   000000   C0E0         PUSH    A
   \   000002   C0D0         PUSH    PSW
   \   000004   C082         PUSH    DPL
   \   000006   C083         PUSH    DPH
   \   000008                ; Saved register size: 4
   \   000008                ; Auto size: 0
    203              T1STAT &= BIT_0(5);     // T1STAT.OVFIF 清除Timer1溢出中断标志
   \   000008   53AFDF       ANL     0xaf,#0xdf
    204              T1STAT &= BIT_0(1);     // T1STAT.CH0IF 清除Timer1通道0中断标志
   \   00000B   53AFFD       ANL     0xaf,#0xfd
    205              IRCON &= BIT_0(1);      // IRCON.T1IF   清除Timer1总中断标志
   \   00000E   C2C1         CLR     0xc0.1
    206              T1_80usCnt++;
   \   000010   90....       MOV     DPTR,#T1_80usCnt
   \   000013   E0           MOVX    A,@DPTR
   \   000014   2401         ADD     A,#0x1
   \   000016   F0           MOVX    @DPTR,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   3400         ADDC    A,#0x0
   \   00001B   F0           MOVX    @DPTR,A
    207          }
   \   00001C   D083         POP     DPH
   \   00001E   D082         POP     DPL
   \   000020   D0D0         POP     PSW
   \   000022   D0E0         POP     A
   \   000024   32           RETI
   \   000025                REQUIRE T1STAT
   \   000025                REQUIRE _A_IRCON
    208          
    209          /***********************************************************
    210          **  函数名称: IRSend_T3IntHandle
    211          **  实现功能: Timer3 红外编码发送中的中断处理函数
    212          **  入口参数: None
    213          **  返回结果: None
    214          ***********************************************************/
    215          #pragma vector = T3_VECTOR

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    216          __near_func __interrupt void IRSend_T3IntHandle(void)
   \                     IRSend_T3IntHandle:
    217          {
   \   000000                ; Saved register size: 1
   \   000000                ; Auto size: 0
    218              TIMIF &= BIT_0(1);      // TIMIF.T3CH0IF
   \   000000   C2D9         CLR     0xd8.1
    219          }
   \   000002   32           RETI
   \   000003                REQUIRE _A_TIMIF

   \                                 In  segment INTVEC, offset 0x4b, root
   \                     `??IRSend_T1IntHandle??INTVEC 75`:
   \   00004B   02....       LJMP       (IRSend_T1IntHandle)

   \                                 In  segment INTVEC, offset 0x5b, root
   \                     `??IRSend_T3IntHandle??INTVEC 91`:
   \   00005B   02....       LJMP       (IRSend_T3IntHandle)

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??GenIR?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GenIR

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??IRSend_T1_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    IRSend_T1_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??IRSend_T3_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    IRSend_T3_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??IRSendInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    IRSendInit
    220          
    221          
    222          #endif  // defined(HAL_IRENC) && (HAL_IRENC == TRUE)

   Maximum stack usage in bytes:

     Function            ISTACK PSTACK XSTACK
     --------            ------ ------ ------
     GenIR                   1      0     12
       -> IRSend_T1_Init     0      0     24
       -> IRSend_T3_Init     0      0     24
     IRSendInit              0      0      0
     IRSend_T1IntHandle      4      0      0
     IRSend_T1_Init          2      0     12
     IRSend_T3IntHandle      1      0      0
     IRSend_T3_Init          0      0     12


   Segment part sizes:

     Function/Label                  Bytes
     --------------                  -----
     _A_P1                              1
     _A_IEN0                            1
     T1STAT                             1
     _A_IEN1                            1
     _A_IRCON                           1
     T3CTL                              1
     T3CCTL0                            1
     T3CC0                              1
     _A_TIMIF                           1
     T1CC0L                             1
     T1CC0H                             1
     T1CTL                              1
     T1CCTL0                            1
     P1SEL                              1
     P2SEL                              1
     P1DIR                              1
     T1_80usCnt                         2
     GenIR                            280
     ?Subroutine4                      15
     ?Subroutine3                      15
     ?Subroutine1                       7
     ?Subroutine0                      12
     ?Subroutine5                      11
     ?Subroutine2                       4
     ?Subroutine6                       9
     IRSendSta                          1
     cntByte                            1
     cntbit                             1
     bitNum                             1
     IRSend_T1_Init                    36
     IRSend_T3_Init                    34
     IRSendInit                         6
     IRSend_T1IntHandle                37
     IRSend_T3IntHandle                 3
     ??IRSend_T1IntHandle??INTVEC 75    3
     ??IRSend_T3IntHandle??INTVEC 91    3
     ??GenIR?relay                      6
     ??IRSend_T1_Init?relay             6
     ??IRSend_T3_Init?relay             6
     ??IRSendInit?relay                 6

 
 429 bytes in segment BANKED_CODE
  24 bytes in segment BANK_RELAYS
   6 bytes in segment INTVEC
  40 bytes in segment NEAR_CODE
  16 bytes in segment SFR_AN
   6 bytes in segment XDATA_Z
 
 493 bytes of CODE  memory (+  6 bytes shared)
   0 bytes of DATA  memory (+ 16 bytes shared)
   6 bytes of XDATA memory

Errors: none
Warnings: none
